\chapter{Synthesis} \label{cha:synthesis} %\thispagestyle{main}
\begin{figure}[ht]
	\centering
	\resizebox{\textwidth}{!}{
		\input{Figures/tikz/system_overview.tex}
	}
	\caption[Simplified overview of the entire system]{Simplified overview of the entire system}
	\label{fig:1_system_overview}
\end{figure}
A simplified overview of the entire system can be seen in \cref{fig:1_system_overview}. Each of the various modules will be explained during this chapter of the report. Initially, the control system will be briefly explained and the reasons for its design choice. Secondly, the signal chain in the transmitter will be outlined and how the transducer is driven by the power stage with the added protective switching circuit. Finally, the analogue front-end will be further explained with its various subcircuits for filtering, amplifying, demodulating, and sampling the signal. Lastly, the design of the \gls{dsp} within the control system will be explained.

\section{Control System}
The choice of platform for the control system is a microcontroller. A microcontroller is a small computer that is built into a single \gls{ic} chip. It includes a \gls{cpu}, memory, and \gls{io} peripherals, and it is designed to perform a specific set of tasks. Microcontrollers are used in a wide range of electronic devices, including appliances, automobiles, industrial control systems, and consumer electronics. Microcontrollers are often used in applications where a small, low-power device is needed to perform simple tasks, such as controlling a motor or reading a sensor. They are usually programmed in a high-level language, such as C or C++, and they can be programmed to perform a variety of tasks, depending on the specific application. The chosen \gls{mcu} for this project is STM32F411RE, because it is sufficient for the application and sourcing limitations within the \gls{ic} supply chain. For implementing the control system, a \gls{rtos} can offer multiple benefits for the embedded system development. A RTOS is an operating system that is designed to handle real-time applications. Real-time applications are those that require timely processing of data in order to function correctly. This can include tasks such as controlling industrial machinery, monitoring and controlling processes. Real-time operating systems are designed to prioritize certain tasks and ensure that they are completed within a specific timeframe. They do this by allocating a certain amount of processing resources to each task, and by interrupting the execution of lower-priority tasks as needed to ensure that high-priority tasks are completed on time. RTOSs typically include features such as preemptive scheduling, real-time communication, and support for multiple processors and hardware architectures. Alternatively, a vendor-locked baremetal implementation is an option, in this case STM32 HAL. Notable differences between the two approaches are, but not limited to:
\begin{itemize}
	\item Multitasking: RTOS allows for parallel execution that enable more complex applications.
	\item Portability: Standard modules mean that the same code can be easily ported to other devices and even other platforms without modifications.
	\item Reduced development time: Especially for rapid prototype development, using pre-existing APIs significantly reduces development time by providing many of the low-level tasks such as scheduling, resource management, and timing by the operating system.
\end{itemize}

\subsection{Development Environment}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_vscode.png}
	\caption[VSCode editor with CMake Tools active]{VSCode editor with CMake Tools active, displaying available tasks}
	\label{fig:3_vscode_cmake_build}
\end{figure}

Visual Studio Code (VSCode) is an \gls{open-source} code editor developed by Microsoft. It is designed to be highly customizable and efficient, with a wide range of features and extensions that allow developers to customize their workflows and improve their productivity. VSCode works in synergy with CMake through an extension. CMake is a cross-platform build system that helps developers manage the build process for their projects. It is used to generate build files for different platforms and build systems, to build projects on a wide range of platforms. When using CMake with VSCode, the basic idea is to use the CMake extension for VSCode to generate the appropriate build files for the target platform, and then use the VSCode tasks and debugging capabilities to build and debug the project. After setup of VSCode, the CMake Tools \cite{cmake} extension can be found in the VSCode Marketplace. The CMake Tools extension allows you to create, configure and build CMake projects from within VSCode. Once the extension is installed, you can create a new CMake project and configure it by specifying the path to the \texttt{CMakeLists.txt} file and other settings like the target platform and build configuration. After configuring the project, the VSCode tasks are provided to build and run the project. These tasks are defined in the \texttt{tasks.json} file, which can be customized to specify the build command and other options. Examples of tasks are build the project, cleaning the build directory, or running tests. The available CMake tasks are shown in \cref{fig:3_vscode_cmake_build}. In addition to building and running the project, VSCode allows for debugging capabilities to debug code.

\subsection{Zephyr}
Zephyr is an \gls{open-source} \gls{rtos} designed to be lightweight and run on a wide range of devices, from \gls{mcu}s with as little as \qty{20}{\kilo\byte} of \gls{ram} to more powerful systems with multiple processors. Zephyr is designed to be modular and scalable, with a focus on security and low power consumption. It includes support for a wide range of hardware architectures, including ARM Cortex-M, x86, and RISC-V, and it can be used with a variety of development boards and microcontrollers. One of the key features of Zephyr is its ability to run on very small devices with limited resources. It includes support for various networking protocols, such as \gls{ble}, IPv4, and IPv6, which makes it well-suited for use in \gls{iot} applications. Zephyr is developed as part of the Linux Foundation's Zephyr Project, and it is widely used in the development of IoT and embedded systems.

\subsubsection{Build System}
To build an application with the Zephyr kernel, you use CMake which has two phases - configuration and build. During configuration phase, CMake executes the \texttt{CMakeLists.txt} build scripts to generate an internal model of the Zephyr build. Starting with \gls{dts} and \gls{dtsi} and then using the device-tree nodes and Kconfig to configure the set of build files for ninja.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_devicetree.pdf}
	\caption[Devicetree input files and output files]{Devicetree input files (green) and output files (yellow) \cite{zephyrprojectdocumentation}}
	\label{fig:3_devicetree}
\end{figure}
Seen in \cref{fig:3_devicetree} is the process in which the build system searches out device-trees in certain locations and merges them into the \texttt{zephyr.dts} that will be used for configuring and mapping every peripheral. Typically, each supported board has a file called \texttt{BOARD.dts} that defines the hardware of the board. The \texttt{BOARD.dts} file includes one or more \texttt{.dtsi} files that describe the CPU or system-on-chip that Zephyr runs on, and other common hardware features shared by multiple boards. These \texttt{.dtsi} files may also include other \texttt{.dtsi} files. Additionally, the \texttt{BOARD.dts} file provides a description of the specific hardware of the board. After parsing the \texttt{BOARD.dts} file, the main point being the merge with the \texttt{.overlay} file specific to both the project and the board. This overlay enables the portability feature of Zephyr. A significant degree of the workload when implementing Zephyr projects are thus in writing hardware devicetrees and then writing as generic firmware implementations as possible. Next, the configuration phase can be seen in \cref{fig:3_cmake_configuration}. Once configuration phase is done, CMake generates build scripts that are native to the host platform and initiate the build sequence with the build system Ninja \cite{ninja}. Afterwards, the generated build scripts are executed to begin the second phase, build. The build scripts can recompile the application without involving CMake after most code changes. Zephyr uses the \enquote{target} concept of CMake to organize the build, where a target can be an executable, a library, or a generated file. The final output of Ninja is a binary file ready for \gls{flashing} using a microcontroller programmer.

\begin{figure}[htbp!]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_configuration.pdf}
	\caption[Configuration phase of a Zephyr application]{Configuration phase of a Zephyr application \cite{zephyrprojectdocumentation}}
	\label{fig:3_cmake_configuration}
\end{figure}
After cmake configuration phase has completed, the build phase begins. CMake invokes the build system, which (conceptually) has five (six, one is repeated) stages: (I) pre-build, (II) generation and compilation, (III) first-pass binary (and (IV) second-pass binary), (V) final binary and (VI) post-processing.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build1.pdf}
	\caption[Flowchart of build stage I, pre-build]{Flowchart of build stage I, pre-build}
	\label{fig:3_build1}
\end{figure}
In \cref{fig:3_build1} the build system binds system call functions to implementations.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build2.pdf}
	\caption[Flowchart of build stage II, generation and compilation]{Flowchart of build stage II, generation and compilation}
	\label{fig:3_build2}
\end{figure}
Next, in \cref{fig:3_build2} the build system collects source files for various subsystems (decided by the configuration phase) and compiles into archives. The \texttt{gen\_app\_partitions.py} script examines all the archives that are produced and creates linker scripts that organize and align application partitions correctly, based on the memory protection hardware of the target. Then \texttt{cpp} process involves merging linker script fragments from various sources, including the target's architecture/\gls{soc}, the kernel tree, partition output (if memory protection is enabled), and any other selected fragments from the configuration process. These are combined into a \texttt{linker.cmd} file. The compiled archives are then linked with \texttt{ld}, following the specifications in the \texttt{linker.cmd} file.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build3.pdf}
	\caption[Flowchart of build stage III, intermediate binary]{Flowchart of build stage III, intermediate binary}
	\label{fig:3_build3}
\end{figure}
Shown in \cref{fig:3_build3} is the process, in which an unfixed size intermediate binary is produced. If a devicetree is being used, an intermediate binary is generated that has a variable size. The binary is not fixed in size, which means that it can be modified by post-processing steps that affect the size of the final binary.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build4.pdf}
	\caption[Flowchart of build stage IV, second intermediate binary]{Flowchart of build stage IV, second intermediate binary}
	\label{fig:3_build4}
\end{figure}
In \Cref{fig:3_build4} the fixed size intermediate binary is generated. The previous stage's binaries are not fully formed and contain sections that are empty or marked as placeholders. These sections must be filled in by a process similar to reflection. To finish building, certain scripts are run on the intermediate binaries. These scripts generate the necessary components that are missing from the final binary.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build5.pdf}
	\caption[Flowchart of build stage V, final binary]{Flowchart of build stage V, final binary}
	\label{fig:3_build5}
\end{figure}
Next, in \cref{fig:3_build5}, the final binary is produced by repeating the link from the previous stage, but this time with all the missing pieces populated.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.6\textwidth]{Figures/3_cmake_build6.pdf}
	\caption[Flowchart of build stage VI, post-processing]{Flowchart of build stage VI, post-processing}
	\label{fig:3_build6}
\end{figure}
Finally, in \cref{fig:3_build6}, using \texttt{GNU objdump}, the completed kernel is converted from a \gls{elf} file to the hex file that is expected by the flash tool compatible with the target device.

%\subsection{Firmware}
%A full repository of the revision controlled codebase is available on GitHub at \cite{github_firmware}.

\section{Pulse Generator}
Initially, a pulse generator was designed by using a programmable synthesizer circuit, but due to constraints within generating complementary PWM with dead-time when driving the half-bridge, a timer based PWM generation in the \gls{mcu} is preferable. In a half-bridge power stage, dead-time refers to the amount of time that elapses between the moment when one of the switches in the half-bridge (either the high-side or the low-side switch) turns off and the moment when the other switch turns on. During the dead-time, both switches in the half-bridge are off, which means that there is no current flowing through either switch in the half-bridge. A scenario where both switches are on, can cause problems if the output of the half-bridge is connected to a load, as it may cause the load to behave erratically or even be damaged. To avoid these problems, it is important to carefully consider the amount of dead-time in a half-bridge power stage. In general, a longer dead-time will reduce the risk of damage to the load, but it will also reduce the efficiency of the power stage, as energy will be lost during the dead-time. Therefore, it is important to carefully balance the trade-off between efficiency and safety in order to determine the optimal amount of dead-time for a given half-bridge power stage. Based on discussions during design review, it was decided to change approach and generate the two complementary PWM signals by configuring the PWM module of the microcontroller with the functionality though with a trade-off in resolution. However, for this application there is no need to amplitude modulate the output signal and therefore no downside.
In the context of a PW Doppler system, it is desired to generate 3 PWM signals:
\begin{itemize}
	\item \qty{5}{\mega\hertz} complementary signal with dead-time for the pulsed burst during transmit mode.
	\item \qty{10}{\kilo\hertz} signal as $f_{\mathrm{prf}}$ for the timing control of the transmit/receive switch.
	\item \qty{20}{\mega\hertz} clock signal for the demodulation circuit in the receiver.
	\item \qty{10}{\kilo\hertz} gate pulse for S/H control with pulse length $t_{\mathrm{pulse}} = N_{\mathrm{pulse}} \times T_{\mathrm{prd}}$, where $T_{\mathrm{prd}} = \sfrac{1}{f_{\mathrm{pwm}}}$
\end{itemize}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{Figures/3_wavedrom.pdf}
	\caption{Timing diagram of various control signals for an arbitrary $n$ length pulse chain expressed by the second diagram gap}
	\label{fig:3_pulse_timing_diagram}
\end{figure}

\section{Power Stage}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{Figures/3_power_stage_block.pdf}
	\label{fig:3_power_stage}
	\caption{Block diagram of power stage \cite{MD1213DB1}}
\end{figure}
Several MOSFET drivers were considered, e.g. ISL55111\cite{ISL55111}, EL7104\cite{EL7104}, and MD1213\cite{MD1213}. The MD1213 has an advantage over the ISL55111 or EL7104 for ultrasound MOSFET drivers since it is specifically designed for high-voltage P-channel and N-channel MOSFETs in medical ultrasound and other applications needing a high output current for a capacitive load. It has a high-speed input stage with a logic interface that can function from \qtyrange{1.8}{5}{\volt} and an ideal operating input signal range of \qtyrange{1.8}{3.3}{\volt}. The DC-coupled adaptive threshold circuit sets the level translator switch threshold to the average of the input logic \gls{low} and logic \gls{high} levels. Consequentially, the MD1213 is designed primarily for driving MOSFETs in medical ultrasound applications, whereas the ISL55111 and EL7104 are more general-purpose drivers that may not perform as well in ultrasound applications. The MD1213's output stage has a distinguishing features in that the \gls{low} and \gls{high} levels of the output signal may be set independently of the rest of the circuit's supply voltages. The input logic levels, for example, might be \qty{0}{\volt} and \qty{1.8}{\volt}, whereas the control logic is powered by \qtyrange[retain-explicit-plus]{+5}{-5}{\volt}. The output \gls{low} and \gls{high} values, on the other hand, may be changed between \qtyrange[retain-explicit-plus]{-5}{+5}{\volt}. This gives you greater flexibility in adjusting the output signal levels to meet individual needs. The output stage may also provide peak currents of up to \qty{2}{\ampere}, depending on the load capacitance and supply voltages employed. Seen in \cref{fig:3_power_stage} is the circuit diagram of the power stage with the gate driver on the left side and the half-bridge on the right side.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_transmitter_sim_out.eps}
	\caption{LTspice simulation output of transmitter with level shifter and half-bridge power stage from \cref{fig:app_ltspice_transmitter}}
	\label{fig:3_transmitter_sim}
\end{figure}
Using a \gls{spice} macro model, an LTspice simulation of the power stage was implemented where the full model can be seen in \cref{fig:app_ltspice_transmitter}. The resulting waveforms are seen in \cref{fig:3_transmitter_sim}. In the top subplot, the input voltages \texttt{INA} and \texttt{INB} are seen with their dead-time visible on each overlapped on period. Since \texttt{INB} is driving an N-channel \gls{mosfet}, the driving pulse-train should be thought of having the opposite polarity. When looking at the middle subplot, it is noted that dead-time is visible as the time where the output voltage is zero. Thus, during that time neither \gls{fet} are allowing a current to pass, and therefore the voltage across the load is equal to zero. The lower subplot shows the maximum ideal power delivery using the peak pulse voltage, assuming the load is equal to \qty{50}{\ohm}. In reality, due to the equipment available for testing, the pulse peak voltage will be less than \qty{100}{\volt}.

\section{Transmit/Receive Switch}
\begin{figure}[htbp]
	\centering
%	\includegraphics[width=.8\textwidth]{circuits/switch.pdf}
	\includegraphics[width=.8\textwidth]{Figures/3_switch_tx810_block.pdf}
	\caption{Block diagram of TX/RX switching circuit where the inputs D1 through D6 are binary decoded from inputs $B_1$, $B_2$, $B_3$ \cite{TX810}}
	\label{fig:3_switch}
\end{figure}
Among the design considerations for the transmit and receive switch were the TX810\cite{TX810} and MD0101\cite{MD0101}. Both ICs are acceptable choices, however the MD0101 is a newer and generally better choice since it has a lower insertion loss, which means that less of the ultrasound signal is lost as it passes through the switch. This results in a higher quality image with better signal-to-noise ratio. Additionally, MD0101 has a wider bandwidth, which means that it can transmit and receive ultrasound signals over a broader range of frequencies. However, since the TX810 is in stock and is also acceptable, it was chosen for the design. TX810 is an IC from Texas Instruments that can be used to switch transmit and receive paths of an ultrasound system. The IC fundamentally works by having a 3-bit programmable pin interface that will open and close the switch with a variable bias current. See \cref{fig:3_tx810_timing} for a visualisation of the switching operation, where \texttt{INPUT} is the incoming Doppler waveform being picked up from the transducer, \texttt{B3/B2/B1} is the switching signal closing the switch and thereby going in receive mode, and \texttt{OUTPUT} is the received signal seen in the \gls{afe}.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_tx810_timing.pdf}
	\caption[Timing diagram of switching interface]{Timing diagram of switching interface where $t_{\mathrm{EN\_ON}}=\qty{0.6}{\micro\second}$, $t_{\mathrm{EN\_OFF}}=\qty{2.4}{\micro\second}$, and $t_{\mathrm{DELAY}}=\qty{1.3}{\nano\second}$ for the condition $B_1=B_2=B_3$ \cite{TX810}}
	\label{fig:3_tx810_timing}
\end{figure}
The TX810 can switch the transmit and receive paths for up to 8 different transducers at the same time. The TX810 is programmed to switch the transmit and receive paths at specific times, as determined by the user. For example, the user can program the TX810 to switch the transmit and receive paths of a particular transducer at a specific time during the ultrasound examination. The IC is typically used in conjunction with an ultrasound system and one or more transducers. Transducers are used to transmit and receive ultrasound waves, which are used to generate images of the body's internal structures. The TX810 is used to switch the transmit and receive paths for each transducer at the appropriate times, allowing the ultrasound system to capture images from multiple angles simultaneously. When high-voltage transmitter signals are applied to the input, the internal diodes limit the output voltage. While in receive mode, the TX810's insertion loss is minimized. The TX810 features a 3-bit interface that may be used to program bias current from \qty{7}{\milli\ampere} to \qty{0}{\milli\ampere} for varying performance and power requirements, unlike conventional T/R switches. The device is put up in power-down mode when the TX810 bias current is set to \qty{0}{\milli\ampere} (high-impedance mode). The TX810 does not put significant load on high-voltage transmitters when operating in the high-impedance mode. A PCB design was implemented in Altium Designer \cite{altium} utilising three channels of the maximum eight available channels in the IC. Seen in \cref{fig:3_ultrasoundswitch} is a 3D render of the designed PCB.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_ultrasoundswitch.png}
	\caption{3D Render of PCB in Altium Designer}
	\label{fig:3_ultrasoundswitch}
\end{figure}
The module is designed with three usable channels, either three separate transducers for multi-angle sonography, or a \gls{cmut} with three channels in a single angle. However, the following experiments with the TX/RX switch, only one channel will be used for simplifying the data acquisition experiments.

\section{Band-Pass Filter}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{Figures/3_bpf_specs.pdf}
	\caption[Band-Pass Filter insertion loss and specifications]{Band-Pass Filter with (above) insertion loss showing a pass band of \qtyrange{2}{7}{\mega\hertz} of \qty{0.5}{\decibel} insertion loss and (below) electrical specifications showing the minimum stop band attenuation of \qty{20}{\decibel}}
	\label{fig:3_bpf_specs}
\end{figure}
After the signal is received, it is filtered with a \gls{bp} filter to remove unwanted noise and interference from the received signal. The presence of these unwanted frequency components can distort the received signal and reduce the quality of the resulting imaging. The specs from the datasheet \cite{BPF} are seen in \cref{fig:3_bpf_specs}. Filtering the received signal through this device means that any signals produced by the transducer at frequencies outside the range of interest will be attenuated. An ultrasound receiver requires a band-pass filter to enable only the frequencies within a predetermined range to pass through, while blocking out frequencies outside that range.

\section{Preamplifier}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_ad8332_block.pdf}
	\caption{Block diagram of preamplifier AD8332 \cite{AD8332}}
	\label{fig:3_preamplifier_block}
\end{figure}
The isolated signal is still rather weak to be measured using digital circuits, and therefore the amplitude must be increased with the preamplifier circuit. This circuit is based on the integrated circuit from Analog Devices AD8332 \cite{AD8332}, which is a device that combines a dual-channel \gls{lna} and \gls{vga}, designed specifically for ultrasound systems. A diagram of its internal functional blocks can be seen in \cref{fig:3_preamplifier_block}. The AD8332 functions at frequencies up to \qty{120}{\mega\hertz}. Each channel includes an ultralow noise preamp (\gls{lna}), a \gls{vga} with \qty{48}{\decibel} of gain range, and a selectable gain postamp with adjustable output limiting. The LNA gain is \qty{19}{\decibel} with a single-ended input and differential outputs. To match the signal source without sacrificing noise performance, the LNA input impedance can be adjusted using a single resistor. The VGA has low output-referred noise, which is useful in driving high-speed differential ADCs. The gain of the postamp can be pin-selected to \qty{3.5}{\decibel} or \qty{15.5}{\decibel}, depending on the converter requirements. The output can be limited to a user-defined clamping level to avoid input overload to a subsequent \gls{adc}, with the clamping level adjusted using an external resistor. A SPICE macromodel is provided by the vendor and the preamplification is succesfully simulated using LTspice with the full LTspice model found in \cref{fig:app_ltspice_preamp}, and the probed inputs and outputs seen in \cref{fig:3_preamplifier_sim}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_preamplifier_sim_out.eps}
	\caption{LTspice simulation output of preamplifier \gls{lna} and \gls{vga} from \cref{fig:app_ltspice_preamp}}
	\label{fig:3_preamplifier_sim}
\end{figure}

\section{Quadrature Demodulator}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_ad8333_block.pdf}
	\caption{Block diagram of demodulator AD8333 \cite{AD8333}}
	\label{fig:3_demodulator_block}
\end{figure}
After the preamplifier, the amplified signal must be demodulated to prepare it for sampling. The device used for quadrature demodulation is an integrated circuit from Analog Devices AD8333 \cite{AD8333} I/Q demodulator. A diagram of the internal functional blocks can be seen in \cref{fig:3_demodulator_block} where the primary inputs are \texttt{RFIP} and \texttt{RFIN}, which are the two differential RF signals from the preamplifier. The RF inputs connect directly to the outputs of the LNA of the preamplifier. The internal \qty{0}{\degree} and \qty{90}{\degree} phases of the local oscillator (LO) are generated by a divide-by-4 circuit that drives the mixers of a matched I/Q demodulator pair. The I and Q outputs are presented as currents, making summation possible. The summed current outputs are then converted to voltages by a high dynamic range, current-to-voltage (I-V) converter, such as the AD8021 \cite{AD8021}, which functions as a transimpedance amplifier. A SPICE macromodel is provided by the vendor and the I/Q demodulation is succesfully simulated using LTspice using the LTspice model found in appendix \cref{fig:app_ltspice_demod}, with the probed inputs and outputs seen in \cref{fig:3_demod_sim_in,fig:3_demod_sim_out}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_demod_sim_in.eps}
	\caption{LTspice simulation demodulator input variables from \cref{fig:app_ltspice_demod}}
	\label{fig:3_demod_sim_in}
\end{figure}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_demod_sim_out.eps}
	\caption{LTspice simulation demodulator output variables Q and I voltages from \cref{fig:app_ltspice_demod}}
	\label{fig:3_demod_sim_out}
\end{figure}
\section{Sample and Hold}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_sample_hold_ad783.pdf}
	\caption{AD783 Sample and Hold Amplifier functional block diagram \cite{AD783}}
	\label{fig:3_sha_block}
\end{figure}
In this system, the sample-and-hold amplifier is necessary to keep values between each sample line. In chapter 2, it was described how the pulsed-wave flow-meter measures the movement of scatterers by sampling the back-scattered signal at a specific depth. Generally, the intended use for this part is in general data acquisition systems such as an \gls{adc}. In that application, the sample-and-hold amplifier captures an analog signal and retains it during certain operations, usually analog-to-digital conversion. Through a S/H input, two possible modes are selected, \textit{sample} or \textit{hold}. During the sample mode of operation, the output of the sample-and-hold amplifier follows the input. During the hold mode of operation, the output may not change by more than 1 \gls{lsb}. The typical usage of a SHA is to keep the ADC input constant throughout the conversion process. With some types of ADCs, but not all, the input cannot change by more than 1 \gls{lsb} during the conversion, or else the process will be compromised. This can either impose very low frequency limits on such ADCs or necessitate their use with a SHA to hold the input during each conversion. An internal capacitor forms the key component of the sample-and-hold amplifier, which serves as the energy storage device. The input amplifier buffers the input signal by presenting a high impedance to the signal source, while providing current gain to charge the hold capacitor. In the sample mode, the voltage on the hold capacitor follows the input signal, albeit with some delay and bandwidth limitations. In the hold mode, the switch is opened, and the capacitor retains the voltage present before being disconnected from the input buffer. The output buffer prevents the held voltage from discharging too soon by offering a high impedance to the hold capacitor. The switching circuit and its driver work together to enable the SHA to alternate between sample and hold modes.

In the pulsed-wave flowmeter, the sample-and-hold amplifier is used to keep each sample value between each gate pulse. This is done for both the I and Q signals in parallel. A diagram of a sample-and-hold operation can be seen in \cref{fig:3_sha_function}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_sample_hold_amplifier_quantization.pdf}
	\caption{Sample and Hold function with input function $f(t)$ over time \cite{sha_pic}}
	\label{fig:3_sha_function}
\end{figure}

\section{Pulse-Repetition, Wall Filter, DC-Coupling}
Finally, the signal should be DC coupled for sampling. Combined with this circuit, a \gls{hp} filter is used as a combined \gls{prf} and Wall-filter in conjunction with a \qty{2}{\decibel} gain amplification to maximize dynamic range of the \gls{adc} measurements from \qtyrange{0}{3.3}{\volt}. A SPICE simulation was implemented and a small signal analysis as well as a transient analysis was conducted. The resulting small signal analysis can be seen in \cref{fig:3_dccoupler_sim_ac} and the transient analysis can be seen in \cref{fig:3_dccoupler_sim_transient}.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_dc_coupler_sim.eps}
	\caption{Small-signal analysis of DC-Coupling filter circuit}
	\label{fig:3_dccoupler_sim_ac}
\end{figure}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_dc_coupler_sim_transient.eps}
	\caption{Transient analysis of DC-Coupling filter circuit}
	\label{fig:3_dccoupler_sim_transient}
\end{figure}
