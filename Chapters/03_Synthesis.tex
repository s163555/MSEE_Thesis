\chapter{Synthesis} \label{cha:synthesis} %\thispagestyle{main}
\begin{figure}[ht]
	\centering
	\resizebox{\textwidth}{!}{
		\input{Figures/tikz/system_overview.tex}
	}
	\caption[Simplified overview of the entire system]{Simplified overview of the entire system}
	\label{fig:1_system_overview}
\end{figure}
A simplified overview of the entire system can be seen in \cref{fig:1_system_overview}. Each of the various modules will be explained during this chapter of the report. Initially, the control system will be briefly explained and the reasons for its design choice. Secondly, the signal chain in the transmitter will be outlined and how the transducer is driven by the power stage with the added protective switching circuit. Finally, the analogue front-end will be further explained with its various subcircuits for filtering, amplifying, demodulating, and sampling the signal. Lastly, the design of the \gls{dsp} within the control system will be explained.

\section{Control System}
The choice of platform for the control system is a microcontroller. A microcontroller is a small computer that is built into a single \gls{ic} chip. It includes a \gls{cpu}, memory, and \gls{io} peripherals, and it is designed to perform a specific set of tasks. Microcontrollers are used in a wide range of electronic devices, including appliances, automobiles, industrial control systems, and consumer electronics. Microcontrollers are often used in applications where a small, low-power device is needed to perform simple tasks, such as controlling a motor or reading a sensor. They are usually programmed in a high-level language, such as C or C++, and they can be programmed to perform a variety of tasks, depending on the specific application. The chosen \gls{mcu} for this project is STM32F411RE, because it is sufficient for the application and sourcing limitations within the \gls{ic} supply chain. For implementing the control system, a \gls{rtos} can offer multiple benefits for the embedded system development. A RTOS is an operating system that is designed to handle real-time applications. Real-time applications are those that require timely processing of data in order to function correctly. This can include tasks such as controlling industrial machinery, monitoring and controlling processes. Real-time operating systems are designed to prioritize certain tasks and ensure that they are completed within a specific timeframe. They do this by allocating a certain amount of processing resources to each task, and by interrupting the execution of lower-priority tasks as needed to ensure that high-priority tasks are completed on time. RTOSs typically include features such as preemptive scheduling, real-time communication, and support for multiple processors and hardware architectures. Alternatively, a vendor-locked baremetal implementation is an option, in this case STM32 HAL. Notable differences between the two approaches are, but not limited to:
\begin{itemize}
	\item Multitasking: RTOS allows for parallel execution that enable more complex applications.
	\item Portability: Standard modules mean that the same code can be easily ported to other devices and even other platforms without modifications.
	\item Reduced development time: Especially for rapid prototype development, using pre-existing APIs significantly reduces development time by providing many of the low-level tasks such as scheduling, resource management, and timing by the operating system.
\end{itemize}

\subsection{Development Environment}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_vscode.png}
	\caption[VSCode editor with CMake Tools active]{VSCode editor with CMake Tools active, displaying available tasks}
	\label{fig:3_vscode_cmake_build}
\end{figure}

Visual Studio Code (VSCode) is an \gls{open-source} code editor developed by Microsoft. It is designed to be highly customizable and efficient, with a wide range of features and extensions that allow developers to customize their workflows and improve their productivity. VSCode works in synergy with CMake through an extension. CMake is a cross-platform build system that helps developers manage the build process for their projects. It is used to generate build files for different platforms and build systems, to build projects on a wide range of platforms. When using CMake with VSCode, the basic idea is to use the CMake extension for VSCode to generate the appropriate build files for the target platform, and then use the VSCode tasks and debugging capabilities to build and debug the project. After setup of VSCode, the CMake Tools \cite{cmake} extension can be found in the VSCode Marketplace. The CMake Tools extension allows you to create, configure and build CMake projects from within VSCode. Once the extension is installed, you can create a new CMake project and configure it by specifying the path to the \texttt{CMakeLists.txt} file and other settings like the target platform and build configuration. After configuring the project, the VSCode tasks are provided to build and run the project. These tasks are defined in the \texttt{tasks.json} file, which can be customized to specify the build command and other options. Examples of tasks are build the project, cleaning the build directory, or running tests. The available CMake tasks are shown in \cref{fig:3_vscode_cmake_build}. In addition to building and running the project, VSCode allows for debugging capabilities to debug code.

\subsection{Zephyr}
Zephyr is an \gls{open-source} \gls{rtos} designed to be lightweight and run on a wide range of devices, from \gls{mcu}s with as little as \qty{20}{\kilo\byte} of \gls{ram} to more powerful systems with multiple processors. Zephyr is designed to be modular and scalable, with a focus on security and low power consumption. It includes support for a wide range of hardware architectures, including ARM Cortex-M, x86, and RISC-V, and it can be used with a variety of development boards and microcontrollers. One of the key features of Zephyr is its ability to run on very small devices with limited resources. It includes support for various networking protocols, such as \gls{ble}, IPv4, and IPv6, which makes it well-suited for use in \gls{iot} applications. Zephyr is developed as part of the Linux Foundation's Zephyr Project, and it is widely used in the development of IoT and embedded systems.

\subsubsection{Build System}
To build an application with the Zephyr kernel, you use CMake which has two phases - configuration and build. During configuration phase, CMake executes the \texttt{CMakeLists.txt} build scripts to generate an internal model of the Zephyr build. Starting with \gls{dts} and \gls{dtsi} and then using the device-tree nodes and Kconfig to configure the set of build files for ninja.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_devicetree.pdf}
	\caption[Devicetree input files and output files]{Devicetree input files (green) and output files (yellow) \cite{zephyrprojectdocumentation}}
	\label{fig:3_devicetree}
\end{figure}
Seen in \cref{fig:3_devicetree} is the process in which the build system searches out device-trees in certain locations and merges them into the \texttt{zephyr.dts} that will be used for configuring and mapping every peripheral. Typically, each supported board has a file called \texttt{BOARD.dts} that defines the hardware of the board. The \texttt{BOARD.dts} file includes one or more \texttt{.dtsi} files that describe the CPU or system-on-chip that Zephyr runs on, and other common hardware features shared by multiple boards. These \texttt{.dtsi} files may also include other \texttt{.dtsi} files. Additionally, the \texttt{BOARD.dts} file provides a description of the specific hardware of the board. After parsing the \texttt{BOARD.dts} file, the main point being the merge with the \texttt{.overlay} file specific to both the project and the board. This overlay enables the portability feature of Zephyr. A significant degree of the workload when implementing Zephyr projects are thus in writing hardware devicetrees and then writing as generic firmware implementations as possible. Next, the configuration phase can be seen in \cref{fig:3_cmake_configuration}. Once configuration phase is done, CMake generates build scripts that are native to the host platform and initiate the build sequence with the build system Ninja \cite{ninja}. Afterwards, the generated build scripts are executed to begin the second phase, build. The build scripts can recompile the application without involving CMake after most code changes. Zephyr uses the \enquote{target} concept of CMake to organize the build, where a target can be an executable, a library, or a generated file. The final output of Ninja is a binary file ready for \gls{flashing} using a microcontroller programmer.

\begin{figure}[htbp!]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_configuration.pdf}
	\caption[Configuration phase of a Zephyr application]{Configuration phase of a Zephyr application \cite{zephyrprojectdocumentation}}
	\label{fig:3_cmake_configuration}
\end{figure}
After cmake configuration phase has completed, the build phase begins. CMake invokes the build system, which (conceptually) has five (six, one is repeated) stages: (I) pre-build, (II) generation and compilation, (III) first-pass binary (and (IV) second-pass binary), (V) final binary and (VI) post-processing.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build1.pdf}
	\caption[Flowchart of build stage I, pre-build]{Flowchart of build stage I, pre-build}
	\label{fig:3_build1}
\end{figure}
In \cref{fig:3_build1} the build system binds system call functions to implementations.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build2.pdf}
	\caption[Flowchart of build stage II, generation and compilation]{Flowchart of build stage II, generation and compilation}
	\label{fig:3_build2}
\end{figure}
Next, in \cref{fig:3_build2} the build system collects source files for various subsystems (decided by the configuration phase) and compiles into archives. The \texttt{gen\_app\_partitions.py} script examines all the archives that are produced and creates linker scripts that organize and align application partitions correctly, based on the memory protection hardware of the target. Then \texttt{cpp} process involves merging linker script fragments from various sources, including the target's architecture/\gls{soc}, the kernel tree, partition output (if memory protection is enabled), and any other selected fragments from the configuration process. These are combined into a \texttt{linker.cmd} file. The compiled archives are then linked with \texttt{ld}, following the specifications in the \texttt{linker.cmd} file.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build3.pdf}
	\caption[Flowchart of build stage III, intermediate binary]{Flowchart of build stage III, intermediate binary}
	\label{fig:3_build3}
\end{figure}
Shown in \cref{fig:3_build3} is the process, in which an unfixed size intermediate binary is produced. If a devicetree is being used, an intermediate binary is generated that has a variable size. The binary is not fixed in size, which means that it can be modified by post-processing steps that affect the size of the final binary.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build4.pdf}
	\caption[Flowchart of build stage IV, second intermediate binary]{Flowchart of build stage IV, second intermediate binary}
	\label{fig:3_build4}
\end{figure}
In \Cref{fig:3_build4} the fixed size intermediate binary is generated. The previous stage's binaries are not fully formed and contain sections that are empty or marked as placeholders. These sections must be filled in by a process similar to reflection. To finish building, certain scripts are run on the intermediate binaries. These scripts generate the necessary components that are missing from the final binary.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_cmake_build5.pdf}
	\caption[Flowchart of build stage V, final binary]{Flowchart of build stage V, final binary}
	\label{fig:3_build5}
\end{figure}
Next, in \cref{fig:3_build5}, the final binary is produced by repeating the link from the previous stage, but this time with all the missing pieces populated.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.6\textwidth]{Figures/3_cmake_build6.pdf}
	\caption[Flowchart of build stage VI, post-processing]{Flowchart of build stage VI, post-processing}
	\label{fig:3_build6}
\end{figure}
Finally, in \cref{fig:3_build6}, using \texttt{GNU objdump}, the completed kernel is converted from a \gls{elf} file to the hex file that is expected by the flash tool compatible with the target device.

%\subsection{Firmware}
%A full repository of the revision controlled codebase is available on GitHub at \cite{github_firmware}.

\section{Pulse Generator}
Initially, a pulse generator was designed by using a programmable synthesizer circuit, but due to constraints within generating complementary PWM with dead-time when driving the half-bridge, a timer based PWM generation in the \gls{mcu} is preferable. In a half-bridge power stage, dead-time refers to the amount of time that elapses between the moment when one of the switches in the half-bridge (either the high-side or the low-side switch) turns off and the moment when the other switch turns on. During the dead-time, both switches in the half-bridge are off, which means that there is no current flowing through either switch in the half-bridge. A scenario where both switches are on, can cause problems if the output of the half-bridge is connected to a load, as it may cause the load to behave erratically or even be damaged. To avoid these problems, it is important to carefully consider the amount of dead-time in a half-bridge power stage. In general, a longer dead-time will reduce the risk of damage to the load, but it will also reduce the efficiency of the power stage, as energy will be lost during the dead-time. Therefore, it is important to carefully balance the trade-off between efficiency and safety in order to determine the optimal amount of dead-time for a given half-bridge power stage. Based on discussions during design review, it was decided to change approach and generate the two complementary PWM signals by configuring the PWM module of the microcontroller with the functionality though with a trade-off in resolution. However, for this application there is no need to amplitude modulate the output signal and therefore no downside.
In the context of a PW Doppler system, it is desired to generate 3 PWM signals:
\begin{itemize}
	\item \qty{5}{\mega\hertz} complementary signal with dead-time for the pulsed burst during transmit mode.
	\item \qty{10}{\kilo\hertz} signal as $f_{\mathrm{prf}}$ for the timing control of the transmit/receive switch.
	\item \qty{20}{\mega\hertz} clock signal for the demodulation circuit in the receiver.
	\item \qty{10}{\kilo\hertz} gating pulse for S/H control
\end{itemize}

\section{Power Stage}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{Figures/3_power_stage_block.pdf}
	\label{fig:3_power_stage}
	\caption{Block diagram of power stage \cite{MD1213DB1}}
\end{figure}
Several MOSFET drivers were considered, e.g. ISL55111\cite{ISL55111}, EL7104\cite{EL7104}, and MD1213\cite{MD1213}. The MD1213 has an advantage over the ISL55111 or EL7104 for ultrasound MOSFET drivers since it is specifically designed for high-voltage P-channel and N-channel MOSFETs in medical ultrasound and other applications needing a high output current for a capacitive load. It has a high-speed input stage with a logic interface that can function from \qtyrange{1.8}{5}{\volt} and an ideal operating input signal range of \qtyrange{1.8}{3.3}{\volt}. The DC-coupled adaptive threshold circuit sets the level translator switch threshold to the average of the input logic \gls{low} and logic \gls{high} levels. Consequentially, the MD1213 is designed primarily for driving MOSFETs in medical ultrasound applications, whereas the ISL55111 and EL7104 are more general-purpose drivers that may not perform as well in ultrasound applications. The MD1213's output stage has a distinguishing features in that the \gls{low} and \gls{high} levels of the output signal may be set independently of the rest of the circuit's supply voltages. The input logic levels, for example, might be \qty{0}{\volt} and \qty{1.8}{\volt}, whereas the control logic is powered by \qtyrange[retain-explicit-plus]{+5}{-5}{\volt}. The output \gls{low} and \gls{high} values, on the other hand, may be changed between \qtyrange[retain-explicit-plus]{-5}{+5}{\volt}. This gives you greater flexibility in adjusting the output signal levels to meet individual needs. The output stage may also provide peak currents of up to \qty{2}{\ampere}, depending on the load capacitance and supply voltages employed. Seen in \cref{fig:3_power_stage} is the circuit diagram of the power stage with the gate driver on the left side and the half-bridge on the right side.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_transmitter_sim_out.eps}
	\caption{LTspice simulation output of transmitter with level shifter and half-bridge power stage from \cref{fig:app_ltspice_transmitter}}
	\label{fig:3_transmitter_sim}
\end{figure}
Using a \gls{spice} macro model, an LTspice simulation of the power stage was implemented. The resulting waveforms are seen in \cref{fig:3_transmitter_sim}. In the top subplot, the input voltages \texttt{INA} and \texttt{INB} are seen with their dead-time visible on each overlapped on period. Since \texttt{INB} is driving an N-channel \gls{mosfet}, the driving pulse-train should be thought of having the opposite polarity. When looking at the middle subplot, it is noted that dead-time is visible as the time where the output voltage is zero. Thus, during that time neither \gls{fet} are allowing a current to pass, and therefore the voltage across the load is equal to zero. The lower subplot shows the maximum ideal power delivery using the peak pulse voltage, assuming the load is equal to \qty{50}{\ohm}. In reality, due to the equipment available for testing, the pulse peak voltage will be less than \qty{100}{\volt}.

\section{Transmit/Receive Switch}
\begin{figure}[htbp]
	\centering
%	\includegraphics[width=.8\textwidth]{circuits/switch.pdf}
	\includegraphics[width=.8\textwidth]{Figures/3_switch_tx810_block.pdf}
	\caption{Block diagram of TX/RX switching circuit \cite{TX810}}
	\label{fig:3_switch}
\end{figure}
Among the design considerations for the transmit and receive switch were the TX810\cite{TX810} and MD0101\cite{MD0101}. Both ICs are acceptable choices, however the MD0101 is a newer and generally better choice since it has a lower insertion loss, which means that less of the ultrasound signal is lost as it passes through the switch. This results in a higher quality image with better signal-to-noise ratio. Additionally, MD0101 has a wider bandwidth, which means that it can transmit and receive ultrasound signals over a broader range of frequencies. However, since the TX810 is in stock and is also acceptable, it was chosen for the design. TX810 is an IC from Texas Instruments that can be used to switch transmit and receive paths of an ultrasound system. The IC fundamentally works by having a 3-bit programmable pin interface that will open and close the switch with a variable bias current. See \cref{fig:3_tx810_timing} for a visualisation of the switching operation, where \texttt{INPUT} is the incoming Doppler waveform being picked up from the transducer, \texttt{B3/B2/B1} is the switching signal closing the switch and thereby going in receive mode, and \texttt{OUTPUT} is the received signal seen in the \gls{afe}.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_tx810_timing.pdf}
	\caption{Timing diagram of switching interface\cite{TX810}}
	\label{fig:3_tx810_timing}
\end{figure}
The TX810 can switch the transmit and receive paths for up to 8 different transducers at the same time. The TX810 is programmed to switch the transmit and receive paths at specific times, as determined by the user. For example, the user can program the TX810 to switch the transmit and receive paths of a particular transducer at a specific time during the ultrasound examination. The IC is typically used in conjunction with an ultrasound system and one or more transducers. Transducers are used to transmit and receive ultrasound waves, which are used to generate images of the body's internal structures. The TX810 is used to switch the transmit and receive paths for each transducer at the appropriate times, allowing the ultrasound system to capture images from multiple angles simultaneously. When high-voltage transmitter signals are applied to the input, the internal diodes limit the output voltage. While in receive mode, the TX810's insertion loss is minimized. The TX810 features a 3-bit interface that may be used to program bias current from \qty{7}{\milli\ampere} to \qty{0}{\milli\ampere} for varying performance and power requirements, unlike conventional T/R switches. The device is put up in power-down mode when the TX810 bias current is set to \qty{0}{\milli\ampere} (high-impedance mode). The TX810 does not put significant load on high-voltage transmitters when operating in the high-impedance mode. A PCB design was implemented in Altium Designer\cite{altium} utilising three channels of the maximum eight available channels in the IC. Seen in \cref{fig:3_ultrasoundswitch} is a 3D render of the designed PCB.
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_ultrasoundswitch.png}
	\caption{3D Render of PCB in Altium Designer}
	\label{fig:3_ultrasoundswitch}
\end{figure}
The module is designed with three usable channels, either three separate transducers for multi-angle sonography, or a \gls{cmut} with three channels in a single angle.

\section{Preamplifier}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_ad8332_block.pdf}
	\caption{Block diagram of preamplifier AD8332 \cite{AD8332}}
	\label{fig:3_preamplifier_block}
\end{figure}
The AD8332 is a device that combines a dual-channel \gls{lna} and \gls{vga}, designed specifically for ultrasound systems. A diagram of its internal functional blocks can be seen in \cref{fig:3_preamplifier_block}. The AD8332  functions at frequencies up to \qty{120}{\mega\hertz}. Each channel includes an ultralow noise preamp (\gls{lna}), a \gls{vga} with \qty{48}{\decibel} of gain range, and a selectable gain postamp with adjustable output limiting. The LNA gain is \qty{19}{\decibel} with a single-ended input and differential outputs. To match the signal source without sacrificing noise performance, the LNA input impedance can be adjusted using a single resistor. The VGA has low output-referred noise, which is useful in driving high-speed differential ADCs. The gain of the postamp can be pin-selected to \qty{3.5}{\decibel} or \qty{15.5}{\decibel}, depending on the converter requirements. The output can be limited to a user-defined clamping level to avoid input overload to a subsequent \gls{adc}, with the clamping level adjusted using an external resistor. In this application, however, only the \gls{lna} is used, and the \gls{lna} is bypassed in the preamplifier configuration. A SPICE macromodel is provided by the vendor and the preamplification is succesfully simulated using LTspice, seen in \cref{fig:3_preamplifier_sim}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_preamplifier_sim_out.eps}
	\caption{LTspice simulation output of preamplifier \gls{lna} and \gls{vga} from \cref{fig:app_ltspice_preamp}}
	\label{fig:3_preamplifier_sim}
\end{figure}

\section{Demodulation}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_ad8333_block.pdf}
	\caption{Block diagram of demodulator AD8333 \cite{AD8333}}
	\label{fig:3_demodulator_block}
\end{figure}

The AD8333\cite{AD8333} is a device that combines dual-phase shifting and I/Q demodulation, allowing for coherent summing and phase alignment of multiple analog data channels. A diagram of the internal functional blocks can be seen in \cref{fig:3_demodulator_block}. This device is ideal for use in beamformer circuits, which are commonly found in high-performance medical ultrasound equipment that utilizes CW Doppler. The RF inputs connect directly to the outputs of the low noise preamplifiers included in the AD8332's dual channels. The internal \qty{0}{\degree} and \qty{90}{\degree} phases of the local oscillator (LO) are generated by a divide-by-4 circuit that drives the mixers of a matched I/Q demodulator pair. The I and Q outputs are presented as currents, making summation possible. The summed current outputs are then converted to voltages by a high dynamic range, current-to-voltage (I-V) converter, such as the AD8021 \cite{AD8021}, which functions as a transimpedance amplifier. The resulting signal is then sent to a sample-and-hold amplifier for sample gating. A SPICE macromodel is provided by the vendor and the I/Q demodulation is succesfully simulated using LTspice, seen in \cref{fig:3_demod_sim_in,fig:3_demod_sim_out}.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_demod_sim_in.eps}
	%	\includegraphics[width=.8\textwidth]{Figures/4_demod_sim_in_square.eps}
	\caption{LTspice simulation demodulator input variables from \cref{fig:app_ltspice_demod}}
	\label{fig:3_demod_sim_in}
\end{figure}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_demod_sim_out.eps}
	%	\includegraphics[width=.8\textwidth]{Figures/4_demod_sim_out_square.eps}
	\caption{LTspice simulation demodulator output variables Q and I voltages from \cref{fig:app_ltspice_demod}}
	\label{fig:3_demod_sim_out}
\end{figure}
\section{Sample and Hold}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_sample_hold_ad783.pdf}
	\caption{AD783 Sample and Hold Amplifier functional block diagram}
	\label{fig:3_sha_block}
\end{figure}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=.8\textwidth]{Figures/3_sample_hold_amplifier_quantization.pdf}
	\caption{Sample and Hold function with input function $f(t)$ over time}
	\label{fig:3_sha_function}
\end{figure}
%\section{Pulse-Repetition and Wall Filter}
